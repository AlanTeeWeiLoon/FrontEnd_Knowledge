// ------------------------- Introduce -------------------------

/* 

// Function 
- Function, Array, Object, Number... is a constructed function (构造函数) - Sample 3
- All constructed function is generate by “new Function"
- Function is not generate by anything, its direct store in memory when run


- All Object is generated by "new Function" (对象一定是通过构造函数产生)
- All function is an object （函数也是对象）
    - function can have attribute (Exp: Array.isArray, Number.isNAN)

*/

// Sample 1
function test1() { // same as "test1 = new Function()"
  return {} // same as "return new Object"
}

console.log("\n\n--------------- Sample 1 ---------------\n\n") 
// Ques: Is object generated in "new test()"? Ans: Yes!
console.log("Sample 1", new test1()) // will return object of "{}" / Object

// Sample 2
function test2() {
   
}

console.log("\n\n--------------- Sample 2 ---------------\n\n") 
console.log("Sample 2", new test2()) // will return object of "test2()" 


// Sample 3
console.log("\n\n--------------- Sample 3 ---------------\n\n") 
console.log("typeof Object", typeof Object) // "function"
console.log("typeof Array", typeof Array) // "function"

// ------------------------- prototype (原型) -------------------------

/*

- Every function got an attribute: prototype (函数原型) - Sample 4
- In default, prototype is a normal object
- In default, prototype got an attribute call "constructor", its also an object, point to constructed function - Sample 5

*/ 

// Sample 4
console.log("\n\n--------------- Sample 4 ---------------\n\n")
console.log("Object.prototype", Object.prototype) // {constructor: f, ...}
console.log("Array.prototype", Array.prototype) // {constructor: f, ...}
console.log("Number.prototype", Number.prototype) // {constructor: f, ...}
console.log("test1.prototype", test1.prototype) // {constructor: f, ...}

var obj = {}

console.log("obj.prototype", obj.prototype) // undefined
// only function got prototype, obj is an Object

// Sample 5
console.log("\n\n--------------- Sample 5 ---------------\n\n")
console.log("test1.prototype.constructor == test1", test1.prototype.constructor == test1) // true
console.log("Object.prototype.constructor == Object", Object.prototype.constructor == Object) // true

// ------------------------- __ptoto__ (隐式原型) -------------------------

/* 

** variable that start with "__" means is system variable, don't simply modify it.

- Every object got an attribute: __proto__
- In default, __proto__ is points to the prototype of the function that created the object

*/ 

// Sample 6
console.log("\n\n--------------- Sample 6 ---------------\n\n")
console.log("test1.__proto__", test1.__proto__) // ƒ () { [native code] }
// function is an object, so it must have __proto__

console.log("({}).__proto__", ({}).__proto__) // {constructor: f, ...}
// an object must have __proto__

console.log("obj.__proto__", obj.__proto__) // {constructor: f, ...}
// an object must have __proto__

console.log("test1.prototype.__proto__", test1.prototype.__proto__) // {constructor: f, ...}
// prototype is an object as well, an object must have __proto__

// Sample 7
console.log("\n\n--------------- Sample 7 ---------------\n\n")
var obj1 = new test2()
var obj2 = new test1()

console.log("obj1.__proto__ === test2.prototype", obj1.__proto__ === test2.prototype) // true
// obj1 is generate by "test2()", so its __proto__ is point to prototype of "test2()"

console.log("obj2.__proto__ === test1.prototype", obj2.__proto__ === test1.prototype) // false
// obj2 is generate by "{} (new Object)", instead of "test1()"

console.log("obj2.__proto__ === Object.prototype", obj2.__proto__ === Object.prototype) // true
// obj2 is generate by "{} (new Object)", so its __proto__ is point to prototype of "Object"


// Question: question.js => Question 1


// ------------------------- prototype chain (原型链) -------------------------

function User(name, age){
    this.name = name
    this.age = age
    this.sayHello = function(){
        console.log("Hello")
    }
}

// Sample 8
console.log("\n\n--------------- Sample 8 ---------------\n\n")
var u1 = new User("Alan", 20)
var u2 = new User("Oscar", 22)

// Question: Is u1.sayHi === u2.sayHi ?
console.log("u1.sayHi === u2.sayHi", u1.sayHi === u2.sayHi) // false

/** 
 * sayHi for both "u1" and "u2" object is not totally same.
 * so every time an object is generate by User(), 
 * will need to recreate the sayHi function again and again but it is same.
 * 
 * sayHi function can be share
 * */ 


// store sayHi function in User prototype
User.prototype.sayHi = function(){
    console.log("Hi")
}

// u1/u2.__proto__ === User.prototype, so they able to trigger sayHi in prototype of User
u1.__proto__.sayHi() // Hi
u2.__proto__.sayHi() // Hi

console.log("u1.__proto__.sayHi() === u2.__proto__.sayHi()", u1.__proto__.sayHi() === u2.__proto__.sayHi()) // true

// Sample 9
console.log("\n\n--------------- Sample 9 ---------------\n\n")
/*
  When accessing attribute of an object:

  1. check whether the object got the attribute, if yes then use
  2. check whether the __proto__ of object got the attribute, if yes then use
  3. In prototype chain, find in order

  
 */

console.log("u1", u1) // {name: Alan, age: 20, sayHello: fn, __proto__: {...}}
u1.sayHi() // Hi
// "u1" still can trigger sayHi although there isn't "sayHi" attribute inside it

console.log("[]", []) // length is 0 
// but still can call .concat(), .filter() ...
// because of it __proto__ got those functions

console.log("[].__proto__",[].__proto__) // {constructor: f, ...}

// Sample 10
console.log("\n\n--------------- Sample 10 ---------------\n\n")

// test2 - customize function (自定义函数)
// obj3 - customize object (自定义对象)
var obj3 = new test2()

console.log("\n\n---------- Customize object (自定义对象) ----------\n\n")
console.log("obj3.__proto__", obj3.__proto__) // {constructor: f, ...}
// obj3 is generate by "new test2()", so its __proto__ will point to prototype of test2()

console.log("obj3.__proto__.__proto__", obj3.__proto__.__proto__) // {constructor: f, ...}
// obj3.__proto__ is an object, object is generate by "new Object", so its __proto__ will point to prototype of Object

console.log("obj3.__proto__.__proto__.__proto__", obj3.__proto__.__proto__.__proto__) // null
//

console.log("\n\n---------- Customize function (自定义函数) ---------\n\n")
console.log("test2.__proto__", test2.__proto__) // ƒ () { [native code] }
// test2 is generate by "new Function", so its __proto__ will point to prototype of Function

console.log("test2.__proto__.__proto__", test2.__proto__.__proto__) // {constructor: f, ...}
// new Function is an object also, so it must have __proto__
// test2.__proto__ is an object, so its __proto__ will point to prototype of Object

console.log("test2.__proto__.__proto__.__proto__", test2.__proto__.__proto__.__proto__) // null

console.log("\n\n---------- Object (构造函数) ---------\n\n")
console.log("Object.__proto__", Object.__proto__) // ƒ () { [native code] }
// Object is generate by "new Function", so its __proto__ will point to prototype of Function

console.log("Object.__proto__.__proto__", Object.__proto__.__proto__) // {constructor: f, ...}
// new Object is an object, so it must have __proto__
// Object.__proto__ is an object, so its __proto__ will point to prototype of Object

console.log("Object.__proto__.__proto__.__proto__", Object.__proto__.__proto__.__proto__) // null

// Sample 11
console.log("\n\n---------- Sample 11 ---------\n\n")

/*

  All function is generate by "new Function", and all their __proto__ is same, so their got same and share attribute

  Special Note:

  1. __proto__ of Function point to its own prototype (Function的隐式原型指向它自身的原型)
  2. __proto__ of prototype of Object is point to null (Object的prototype的__proto__指向null)
  
 */

console.log("test2.call",test2.call) // ƒ call() { [native code] }
console.log("test2.apply",test2.apply) // ƒ apply() { [native code] }
console.log("test2.bind",test2.bind) // ƒ bind() { [native code] }

// console.dir(test2) // => uncomment and try

// inside test2 will don't have any of the function above
// all the function are come from __proto__, which is "Function.prototype"

//console.dir(Function.prototype) // => uncomment and try

// Same idea apply for Array, Object..., they all also generate by "new Function"

//console.dir(Array.call) // => uncomment and try
//console.dir(Object.call) // => uncomment and try
console.log("Object.call===Array.call",Object.call===Array.call) // true






